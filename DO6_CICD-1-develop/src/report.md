# Basic CI/CD

### Part 1. Настройка **gitlab-runner**

>**== Задание ==**
>
>##### Подними виртуальную машину Ubuntu Server 22.04 LTS.*
>*Будьте готовы, что в конце проекта нужно будет сохранить дамп образа виртуальной машины*

>##### Скачать и установить на виртуальную машину **gitlab-runner**
- ![basic_ci_cd](./images/1_2.png)
>##### Запустить **gitlab-runner** и зарегистрировать его для использования в текущем проекте (*DO6_CICD*)
>- Для регистрации понадобятся URL и токен, которые можно получить на страничке задания на платформе.
- ![basic_ci_cd](./images/1_1.png)

### Part 2. Сборка

>**== Задание ==**
>
>#### Написать этап для **CI** по сборке приложений из проекта *C2_SimpleBashUtils*:
>
>##### В файле _gitlab-ci.yml_ добавить этап запуска сборки через мейк файл из проекта _C2_
>
>##### Файлы, полученные после сборки (артефакты), сохранять в произвольную директорию со сроком хранения 30 дней.
- Скопировал папки cat и grep из проекта simpleBashUtils в папку src проекта CICD: 

- создал и описал файл .gitlab-ci.yml 
    - Файл .gitlab-ci.yml - это файл конфигурации для настройки и определения задач и пайплайнов непрерывной интеграции и непрерывной доставки (CI/CD) в GitLab. В этом файле вы описываете, какие шаги должны выполняться автоматически при каждом пуше кода в ваш репозиторий. После добавления .gitlab-ci.yml файла в ваш репозиторий, GitLab CI/CD будет автоматически создавать пайплайны и выполнять задачи согласно вашим настройкам. Вы сможете видеть результаты выполнения задач в веб-интерфейсе GitLab, а также настраивать уведомления, автоматическое развертывание и другие аспекты CI/CD процесса.

- ![basic_ci_cd](./images/2_1.png)

- ![basic_ci_cd](./images/2_2.png)

### Part 3. Тест кодстайла

>**== Задание ==**
>
>#### Написать этап для **CI**, который запускает скрипт кодстайла (*clang-format*):
>
>##### Если кодстайл не прошел, то "зафейлить" пайплайн
- ![basic_ci_cd](./images/3_1.png)

- ![basic_ci_cd](./images/3_11.png)

>##### В пайплайне отобразить вывод утилиты *clang-format*
- ![basic_ci_cd](./images/3_2.png)

### Part 4. Интеграционные тесты

>**== Задание ==**
>
>#### Написать этап для **CI**, который запускает ваши интеграционные тесты из того же проекта:
>
>##### Запускать этот этап автоматически только при условии, если сборка и тест кодстайла прошли успешно
>
>##### Если тесты не прошли, то "зафейлить" пайплайн
- Мои тесты возвращают 2 строки:  количество SUCCESS и FAIL тестов. Таким образом для фела пеплайна необходимо чтобы в строке FAIL было значение не 0, то есть хотябы 1 тест был зафейлен. Для этого в скрипте запускаем тесты и смотрим на строку FAIL, если она не равна 0, то роняем пеплайн.
- ![basic_ci_cd](./images/4_1.png)
>##### В пайплайне отобразить вывод, что интеграционные тесты успешно прошли / провалились
- ![basic_ci_cd](./images/4_2.png) 

### Part 5. Этап деплоя

>**== Задание ==**
>
>##### Поднять вторую виртуальную машину *Ubuntu Server 22.04.04 LTS*
- ![basic_ci_cd](./images/5_5.png)
>#### Написать этап для **CD**, который "разворачивает" проект на другой виртуальной машине:
>##### Запускать этот этап вручную при условии, что все предыдущие этапы прошли успешно
- необходимо перенастроить сетевые адаптеры обеих машин следующим образом:

- ![basic_ci_cd](./images/5_1.png)

- ![basic_ci_cd](./images/5_12.png)

>##### Написать bash-скрипт, который при помощи **ssh** и **scp** копирует файлы, полученные после сборки (артефакты), в директорию */usr/local/bin* второй виртуальной машины
- ip машины получаем командой `ip a`

- ![basic_ci_cd](./images/5_14.png)
>##### В файле _gitlab-ci.yml_ добавить этап запуска написанного скрипта

- ![basic_ci_cd](./images/5_15.png)
>В результате вы должны получить готовые к работе приложения из проекта *C2_SimpleBashUtils* (s21_cat и s21_grep) на второй виртуальной машине.

- ![basic_ci_cd](./images/5_6.png)

### Part 6. Дополнительно. Уведомления

**== Задание ==**

##### Настроить уведомления о успешном/неуспешном выполнении пайплайна через бота с именем "[ваш nickname] DO6 CI/CD" в *Telegram*
- первым делом необходимо получить токен бота. Для этого используем инфраструктуру телеграма, а точнее главного бота "BotFather". Выполняем команды указаные ниже и получаем токен и id у воторого бота.
- ![basic_ci_cd](./images/6_4.png)

- ![basic_ci_cd](./images/6_5.png)

- добавляем выполнение скрипта после каждого этапа, итоговый файл .gitlab-ci.yml выглядит так:
- ![basic_ci_cd](./images/6_1.png)

- ![basic_ci_cd](./images/6_2.png)

- коммитим, пушим и проверяем работу бота

- ![basic_ci_cd](./images/6_3.png)
